// breakpoint;
// Pushing BP of current process because expl program does not save the BP while the schduler is called from the timer
multipush(BP);
// 2 Obtain the PID of currently executing process from System Status Table.



alias processTableEntryAddress R1;
processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16;


// Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary.
[processTableEntryAddress + 12] = SP % PAGE_SIZE;
[processTableEntryAddress + 14] = PTBR;
[processTableEntryAddress + 15] = PTLR;

// call AQUIRE SCHEDULER LOCK
multipush(R1);
R1 = ACQUIRE_SCHED_LOCK;
call ACCESS_CONTROL;
multipop(R1);

alias newPID R2;

alias newProcessTableEntryAddress R3;
alias otherCoreProcessId R4;


newPID = -1;

if(CORE == PRIMARY_CORE) then 


    if( [SYSTEM_STATUS_TABLE + 5] != 0 ) then

        if([PROCESS_TABLE + 16*SWAPPER_DAEMON +4] != WAIT_DISK) then
            newPID = SWAPPER_DAEMON;
        else   
            newPID = IDLE_PROCESS;
        endif;

    endif;
    
    if([SYSTEM_STATUS_TABLE + 7] == 1 && [SYSTEM_STATUS_TABLE+6] != IDLE2_PROCESS) then
        newPID = IDLE_PROCESS;
    endif;

    otherCoreProcessId = [SYSTEM_STATUS_TABLE + 6];
else 

    if([SYSTEM_STATUS_TABLE + 5] != 0 || [SYSTEM_STATUS_TABLE + 7] == 1) then
        newPID = IDLE2_PROCESS;
    endif;

    otherCoreProcessId = [SYSTEM_STATUS_TABLE + 1];

endif;



if(newPID == -1) then
    alias iter R8;
    alias currentPID R9;
    currentPID = [SYSTEM_STATUS_TABLE + 5*CORE + 1] ;
    iter =  currentPID+1 ; // current id +1

    while(iter != currentPID) do
        processTableEntryAddress = PROCESS_TABLE + iter * 16;
        
        if((iter != otherCoreProcessId) && ([processTableEntryAddress+6] == 0) && ([processTableEntryAddress + 4] == READY || [processTableEntryAddress + 4] == CREATED)  ) then
            if(CORE == PRIMARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != SWAPPER_DAEMON) then
                newPID = iter;
                break;
            else
                if(CORE == SECONDARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != LOGIN_PROCESS && iter != SHELL_PROCESS && iter != SWAPPER_DAEMON) then
                    newPID = iter;
                    break;
                endif;
            endif;
        endif;
        iter=(iter+1)%16;
    endwhile;

    if(newPID == -1) then
        if(CORE == PRIMARY_CORE) then
            newPID = IDLE_PROCESS;
        else
            newPID = IDLE2_PROCESS;
        endif;
    endif;

endif;







//  Restore the SP, PTBR and PTLR values from the Process Table entry for the new process.
newProcessTableEntryAddress = PROCESS_TABLE + newPID * 16;


// Set the PID field of the System Status Table as newPID.
[SYSTEM_STATUS_TABLE + 5*CORE + 1] = newPID;
[newProcessTableEntryAddress + 9] = 0; // MODE FLAG
PTBR = [newProcessTableEntryAddress + 14];
PTLR = [newProcessTableEntryAddress + 15];

if([newProcessTableEntryAddress + 4] == CREATED) then
    
    [newProcessTableEntryAddress + 4] = RUNNING;

    // Store the value in the first word of the kernel stack to the BP register.    
    BP = [[newProcessTableEntryAddress + 11] * PAGE_SIZE];
    // calling RELEASE SCHEDULER LOCK
    multipush(R1,R2,R3);
    R1 = RELEASE_LOCK;
    R2 = SCHED_LOCK;
    call ACCESS_CONTROL;
    multipop(R1,R2,R3);
    
    SP = [newProcessTableEntryAddress +13];
    ireturn;
endif;

[newProcessTableEntryAddress + 4] = RUNNING;

//Set back Kernel SP, PTBR , PTLR
// calling RELEASE SCHEDULER LOCK
multipush(R1,R2,R3);
R1 = RELEASE_LOCK;
R2 = SCHED_LOCK;
call ACCESS_CONTROL;
multipop(R1,R2,R3);
SP =  [newProcessTableEntryAddress + 11] * PAGE_SIZE + [newProcessTableEntryAddress + 12] ;

multipop(BP);
return;
