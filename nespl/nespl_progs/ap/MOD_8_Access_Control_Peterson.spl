
define TURN_KERN_LOCK 29576;
define FLAGS_KERN_LOCK 29579;
define TURN_SCHED_LOCK 29577;
define FLAGS_SCHED_LOCK 29581;

alias functionNumber R1;


if(functionNumber == ACQUIRE_KERN_LOCK) then

	alias processTableEntryAddress R3;
	processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16;

	if(CORE == SECONDARY_CORE && ([SYSTEM_STATUS_TABLE + 5] == 1 || [SYSTEM_STATUS_TABLE + 7] == 1)) then
		[processTableEntryAddress + 4] = READY;
		multipush(R1,R2,R3);
		call SCHEDULER;
		multipop(R1,R2,R3);
	endif;

	alias otherCore R2;
	otherCore = 1 - CORE;

	[FLAGS_KERN_LOCK + CORE] = 1;
	[TURN_KERN_LOCK] = otherCore;

	while([FLAGS_KERN_LOCK + otherCore] == 1 && [TURN_KERN_LOCK] == otherCore) do
		continue;
	endwhile;
	
endif;


if(functionNumber == ACQUIRE_SCHED_LOCK) then

	

	// find the other core
	alias otherCore R2;
	otherCore = 1 - CORE;

	// Set the Ready Flag of the current core to true ( meaning the current program is ready to enter the critical state)
	[FLAGS_SCHED_LOCK + CORE] = 1;
	// Then give the turn to enter the critical state to the other core
	// Set the turn lock to the other core
	[TURN_SCHED_LOCK] = otherCore;

	
	// while its the other cores turn wait in a spin lock
	while([FLAGS_SCHED_LOCK + otherCore] == 1 && [TURN_SCHED_LOCK] == otherCore) do
		continue;
	endwhile;



	
endif;

// not used
if(functionNumber  == ACQUIRE_GLOCK) then
    // Arguements are NIL
    // Returns NIL
    
    // Acquires GLOCK which is a general purpose lock variable that is currently left unused.
   
    while(tsl(GLOCK) == 1) do
        continue;
    endwhile;

endif;

if(functionNumber == RELEASE_LOCK) then
	alias lockVarAddress R2;

	if(lockVarAddress == KERN_LOCK) then
		[FLAGS_KERN_LOCK + CORE] = 0;
	endif;
	if(lockVarAddress == SCHED_LOCK) then
		[FLAGS_SCHED_LOCK + CORE] = 0;
	endif;

	
endif;

return;